#include <stdio.h>
#include <math.h>
#include <assert.h>

const double delta = 1e-6;

enum n_roots
{
    INFINITE_ROOTS = -1,
    NO_ROOTS = 0,
    ONE_ROOT = 1,
    TWO_ROOTS = 2
};
enum enter_variety
{
    E_TEST = 't',
    E_SOLVER = 's',
    E_QUIT = 'q'
};

struct s_coef
{
    double a;
    double b;
    double c;
};

struct for_test
{
    int n_test;
    int roots_Right;       //
};

struct s_roots
{
    double x_1;
    double x_2;
};

struct test_Data
{
    s_coef c_data;
    s_roots r_data;
    for_test n_data;

};

int Equation_Solver(s_coef coef_, s_roots * roots_);
int Double_Comparison_With_Zero(double number);
int Quadratic_Solver(s_coef coef, s_roots * roots_);
int Linear_Solver(double b, double c, double * x_1);
int Tester(test_Data test);
int Double_Comparison(double number_1, double number_2);
void Start_Input();
void Choice(int enter);
void Go_Solve();
void Print_Answer(int roots, double x_1, double x_2);
void Input_Checker(double * a, double * b, double * c);
void Structure_Tests();
void Checker();
void Buffer_Clear();

int main()
{
    Start_Input();

    return 0;
}

//========================================================================================================================================================================

// TODO getmode()

void Start_Input()
{
    printf("WELCOME TO MY SOLVER FOR QUADRATIC(ax^2+bx+c=0) EQUATIONS\n");

    int enter = 0;

    while (enter != 'q' && enter != 's' && enter != 't')
    {
        printf("PRESS t TO DO AUTO TESTS OR s TO ENTER a b c OR q TO QUIT\n");

        enter = getchar();

        if (getchar() != '\n')
        {
            printf("!!!ERROR!!!\nTRY AGAIN\n");

            Buffer_Clear();

            enter = 0;
        }
        else
        {
            Choice(enter);
        }
    }
}

void Choice(int enter)
{
    switch(enter)
    {
        case E_TEST:
        {
            Structure_Tests();
            break;
        }
        case E_QUIT:
        {
            break;
        }
        case E_SOLVER:
        {
            Go_Solve();
            break;
        }
        default:
        {
            printf("!!!ERROR!!!\nTRY AGAIN\n");
        }
    }
}
void Go_Solve()
{
    struct s_coef coef = {0, 0, 0};
    struct s_roots s_roots = {NAN, NAN};

    printf("ENTER a b c\n");

    scanf("%lg %lg %lg", &coef.a, &coef.b, &coef.c);        // TODO check input coef

    int roots = Equation_Solver(coef, &s_roots);

    Print_Answer(roots, s_roots.x_1, s_roots.x_2);

}
//========================================================================================================================================================================

int Equation_Solver(s_coef coef_, s_roots * roots_)
{
    assert(roots_);

    if (Double_Comparison_With_Zero(coef_.a))
    {
        return Linear_Solver(coef_.b, coef_.c, &(roots_->x_1));
    }
    else if (Double_Comparison_With_Zero(coef_.c))
    {
        roots_ -> x_1 = 0;
        roots_ -> x_2 = -coef_.b/coef_.a;
        return TWO_ROOTS;
    }
    else
    {
        return Quadratic_Solver(coef_, roots_);
    }

    return 0;
}

int Linear_Solver(double b, double c, double * x_1)
{
    assert(x_1);

    if (Double_Comparison_With_Zero(b))
    {
        if (Double_Comparison_With_Zero(c))
        {
            return INFINITE_ROOTS;
        }
        else
        {
            return NO_ROOTS;
        }
    }
    else
    {
        *x_1 = -c / b;

        return ONE_ROOT;
    }

    return 0;
}

// TODO c == 0

int Quadratic_Solver(s_coef coef, s_roots * roots_)
{
    assert(roots_);
    double Discriminant = coef.b*coef.b - 4*coef.a*coef.c;

    if (Discriminant < -delta)
    {
        return NO_ROOTS;
    }
    else if (Double_Comparison_With_Zero(Discriminant))
    {
        roots_ -> x_1 = -coef.b / (2 * coef.a);
        return ONE_ROOT;
    }
    else
    {
        roots_ -> x_1 = (-coef.b + sqrt(Discriminant)) / (2 * coef.a);
        roots_ -> x_2 = (-coef.b - sqrt(Discriminant)) / (2 * coef.a);
        return TWO_ROOTS;
    }
    return 0;
}

//==============================================================================================================================================================================

// rename func name

void Print_Answer(int roots, double x_1, double x_2)
{
    switch(roots)
    {
        case NO_ROOTS:
        {
            printf("NO ROOTS");
            break;
        }
        case ONE_ROOT:
        {
            printf("ONE ROOT. ROOT %lg", x_1);
            break;
        }
        case TWO_ROOTS:
        {
            printf("TWO ROOTS. FIRST ROOT %lg, SECOND ROOT %lg", x_1, x_2);
            break;
        }
        case INFINITE_ROOTS:
        {
            printf("AN INFINITE NUMBER OF ROOTS");
            break;
        }
        default:
        {
            printf("ERROR!!! UNKNOWN NUMBER OF ROOTS");
            break;
        }
    }
}
              // function for one concrete test, other func call
void Structure_Tests()
{
    const int n_test = 10;
    struct test_Data test[n_test] = {{{ 0,   0,   0},    {NAN,  NAN},  {1, -1}},
                                     {{  0,   0,   1},    {NAN,  NAN},  {2,  0}},
                                     {{  1,   2,  -3},    {  1,   -3},  {3,  2}},
                                     {{  0,   2,   2},    { -1,  NAN},  {4,  1}},
                                     {{  1,   1,  10},    {NAN,  NAN},  {5,  0}},
                                     {{  2,   4,   2},    { -1,  NAN},  {6,  1}},
                                     {{  5,   1,  -4},    {0.8,   -1},  {7,  2}},
                                     {{0.5,   1,  -4},    {  2,   -4},  {8,  2}},
                                     {{1.5,   9,   0},    {  0,   -6},  {9,  2}},
                                     {{ 10,   9,  -1},    {0.1,   -1},  {10,  2}}};
    int count = 0;

    for(int i = 0; i < n_test; i++)
    {
        if (Tester(test[i]))
            count++;
    }
    printf("\n%d TESTS COMPLETE SUCCESSFULLY\n\n", count);
}

int Tester(test_Data test)
{
    struct s_roots start_roots = {NAN, NAN};

    int roots = Equation_Solver(test.c_data, &start_roots);

    if ((Double_Comparison(start_roots.x_1, test.r_data.x_1) == 1 || (isnan(start_roots.x_1) && isnan(test.r_data.x_1)))&&
        (Double_Comparison(start_roots.x_2, test.r_data.x_2) == 1 || (isnan(start_roots.x_2) && isnan(test.r_data.x_2)))&&
        roots == test.n_data.roots_Right)
    {
        printf("TEST %d SUCCESSED (FIRST ROOT - %lg (%lg), SECOND ROOT - %lg (%lg), NUMBER OF ROOTS - %d (%d))\n",
                test.n_data.n_test, start_roots.x_1, test.r_data.x_1, start_roots.x_2, test.r_data.x_2, roots, test.n_data.roots_Right);
        return 1;
    }
    else
    {
        printf("ERROR TEST %d!!! FIRST ROOT %lg, SECOND ROOT %lg, NUMBER OF ROOTS %d\n"
               "EXPECTED FIRST ROOT %lg, SECOND ROOT %lg,NUMBER OF ROOTS %d\n",
                test.n_data.n_test, start_roots.x_1, start_roots.x_2, roots, test.r_data.x_1, test.r_data.x_2, test.n_data.roots_Right);
    }
    return 0;
}

int Double_Comparison_With_Zero(double number)
{
    if (fabs(number) < delta)
    {
        return 1;
    }
    return 0;
}

int Double_Comparison(double number_1, double number_2)
{
    if (Double_Comparison_With_Zero(number_1 - number_2))
    {
        return 1;
    }

    return 0;
}

void Buffer_Clear()
{
    int ch = 0;
    while ((ch = getchar()) != '\n' && ch != EOF) {}
}
