#include <stdio.h>
#include <math.h>
#include <assert.h>

const double DELTA = 1e-8;
const int EOF_NUMBER = 26;

enum N_ROOTS
{
    INFINITE_ROOTS = -1,
    NO_ROOTS = 0,
    ONE_ROOT = 1,
    TWO_ROOTS = 2
};

enum ENTER_VALUE
{
    E_TEST = 't',
    E_SOLVER = 's',
    E_QUIT = 'q'
};

struct coefValue
{
    double a;
    double b;
    double c;
};

struct rootsValue
{
    double x_1;
    double x_2;
    int n_roots;
};

struct testData
{
    coefValue c_data;
    rootsValue r_data;
};

int DoubleComparisonWithZero(double number);
int QuadraticSolver(coefValue coef, rootsValue * roots_data);
int LinearSolver(double b, double c, double * x_1);
int Tester(int n_test ,testData test);
int DoubleComparison(double number_1, double number_2);
void RootsComparison(double * x_1, double * x_2);
void MinusZero(double * number);
void EquationSolver(coefValue coef, rootsValue * roots_data);
void StartInput();
void Choice(int enter);
void GoSolve();
void CoefInput(coefValue * coef_data);
void PrintAnswer(int roots, double x_1, double x_2);
void StructureTests();
void Checker();
void BufferClear();

int main()
{
    StartInput();
}

void StartInput()
{
    printf("\x1b[92mWELCOME TO MY SOLVER FOR QUADRATIC(ax^2+bx+c=0) EQUATIONS\x1b[0m\n");

    int enter = 0;

    while (enter != 'q' && enter != 's' && enter != 't')
    {
        printf("\x1b[93mPRESS t TO DO AUTO TESTS OR s TO ENTER a b c OR q TO QUIT\x1b[0m\n");

        enter = getchar();

        if (enter != -1)
        {
            if (getchar() != '\n')
            {
                printf("\x1b[31mERROR!!! TRY AGAIN\x1b[0m\n");

                BufferClear();

                enter = 0;
            }
            else
            {
                Choice(enter);
            }
        }
        else
        {
            printf("\x1b[31mERROR!!! TRY AGAIN\x1b[0m\n");

            enter = 0;
        }
    }
}

void Choice(int enter)
{
    assert(isfinite(enter));

    switch(enter)
    {
        case E_TEST:
        {
            StructureTests();
            break;
        }
        case E_QUIT:
        {
            break;
        }
        case E_SOLVER:
        {
            GoSolve();
            break;
        }
        default:
        {
            printf("\x1b[31mERROR!!! TRY AGAIN\x1b[0m\n");
        }
    }
}

void GoSolve()
{

    struct coefValue coef_data = {0, 0, 0};
    struct rootsValue roots_data = {NAN, NAN, 0};

    CoefInput(&coef_data);

    EquationSolver(coef_data, &roots_data);

    MinusZero(&roots_data.x_1);
    MinusZero(&roots_data.x_2);

    RootsComparison(&roots_data.x_1, &roots_data.x_2);

    PrintAnswer(roots_data.n_roots, roots_data.x_1, roots_data.x_2);

}

void CoefInput(coefValue * coef_data)
{
    assert(coef_data);

    printf("\x1b[93mENTER IN FORMAT a b c\x1b[0m\n");

    int counter = 0;

    while (counter != 3)
    {
        counter = scanf("%lg %lg %lg", &(coef_data -> a), &(coef_data -> b), &(coef_data -> c));

        switch(counter)
        {
            case 3:
            {
                int ch = 0;

                if ((ch = getchar()) != '\n' && ch != EOF && ch != EOF_NUMBER)
                {
                    counter = 0;

                    BufferClear();

                    printf("\x1b[31mERROR!!! TRY AGAIN\x1b[0m\n");
                }
                break;
            }
            case -1:
            {
                printf("\x1b[31mERROR!!! TRY AGAIN\x1b[0m\n");

                break;
            }
            default:
            {
                BufferClear();

                printf("\x1b[31mERROR!!! TRY AGAIN\x1b[0m\n");

                break;
            }
        }
    }
}

void EquationSolver(coefValue coef_data, rootsValue * roots_data)
{
    assert(roots_data != 0);
    assert(isfinite(coef_data.a) == 1);
    assert(isfinite(coef_data.b) == 1);
    assert(isfinite(coef_data.c) == 1);

    if (DoubleComparisonWithZero(coef_data.a))
    {
        roots_data -> n_roots = LinearSolver(coef_data.b, coef_data.c, &(roots_data->x_1));
    }
    else if (DoubleComparisonWithZero(coef_data.c))
    {
        roots_data -> x_1 = 0;
        roots_data -> x_2 = -coef_data.b / coef_data.a;
        roots_data -> n_roots = TWO_ROOTS;
    }
    else
    {
        roots_data -> n_roots = QuadraticSolver(coef_data, roots_data);
    }
}

int LinearSolver(double b, double c, double * x_1)
{
    assert(isfinite(b) == 1);
    assert(isfinite(c) == 1);
    assert(x_1 != 0);

    if (DoubleComparisonWithZero(b))
    {
        if (DoubleComparisonWithZero(c))
        {
            return INFINITE_ROOTS;
        }
        else
        {
            return NO_ROOTS;
        }
    }
    else
    {
        *x_1 = -c / b;

        return ONE_ROOT;
    }

    return 0;
}

int QuadraticSolver(coefValue coef_data, rootsValue * roots_data)
{
    assert(roots_data);
    assert(isfinite(coef_data.a) == 1);
    assert(isfinite(coef_data.b) == 1);
    assert(isfinite(coef_data.c) == 1);

    double Discriminant = coef_data.b * coef_data.b - 4 * coef_data.a * coef_data.c;

    if (Discriminant < -DELTA)
    {
        return NO_ROOTS;
    }
    else if (DoubleComparisonWithZero(Discriminant))
    {
        roots_data -> x_1 = -coef_data.b / (2 * coef_data.a);
        return ONE_ROOT;
    }
    else
    {
        roots_data -> x_1 = (-coef_data.b + sqrt(Discriminant)) / (2 * coef_data.a);
        roots_data -> x_2 = (-coef_data.b - sqrt(Discriminant)) / (2 * coef_data.a);
        return TWO_ROOTS;
    }
    return 0;
}

void PrintAnswer(int roots, double x_1, double x_2)
{
    switch(roots)
    {
        case NO_ROOTS:
        {
            printf("\x1b[93mNO ROOTS\x1b[0m");
            break;
        }
        case ONE_ROOT:
        {
            printf("\x1b[93mONE ROOT. x = %lg\x1b[0m", x_1);
            break;
        }
        case TWO_ROOTS:
        {
            printf("\x1b[93mTWO ROOTS. x1 = %lg, x2 = %lg\x1b[0m", x_1, x_2);
            break;
        }
        case INFINITE_ROOTS:
        {
            printf("\x1b[93mAN INFINITE NUMBER OF ROOTS\x1b[0m");
            break;
        }
        default:
        {
            printf("\x1b[31mERROR!!! UNKNOWN NUMBER OF ROOTS\x1b[0m");
            break;
        }
    }
}

void StructureTests()
{
    const int n_test = 11;
                                  //{{  a,   b,   c}, {x_1,  x_2, n_roots}}
    struct testData test[n_test] = {{{  0,   0,   0}, {NAN,  NAN,      -1}},
                                    {{  1,   0,   0}, {NAN,  NAN,       0}},
                                    {{  1,   2,  -3}, {  1,   -3,       2}},
                                    {{  0,   2,   2}, { -1,  NAN,       1}},
                                    {{  1,   1,  10}, {NAN,  NAN,       0}},
                                    {{  2,   4,   2}, { -1,  NAN,       1}},
                                    {{  5,   1,  -4}, {0.8,   -1,       2}},
                                    {{0.5,   1,  -4}, {  2,   -4,       2}},
                                    {{1.5,   9,   0}, {  0,   -6,       2}},
                                    {{ 10,   9,  -1}, {0.1,   -1,       2}},
                                    {{  4,  -2,   0}, {0.5,    0,       2}}};
    int count = 0;

    for(int i = 0; i < n_test; i++)
    {
        if (Tester(i, test[i]))
            count++;
    }
    printf("\x1b[93m==============================\x1b[0m\n");
    printf("\x1b[93m%d TESTS COMPLETE SUCCESSFULLY\x1b[0m\n", count);
    printf("\x1b[93m==============================\x1b[0m\n");
}

int Tester(int n_test, testData test)
{
    struct rootsValue roots_data = {NAN, NAN, 0};

    EquationSolver(test.c_data, &roots_data);

    MinusZero(&roots_data.x_1);
    MinusZero(&roots_data.x_2);

    RootsComparison(&roots_data.x_1, &roots_data.x_2);

    if ((DoubleComparison(roots_data.x_1, test.r_data.x_1) == 1 || (isnan(roots_data.x_1) && isnan(test.r_data.x_1)))&&
        (DoubleComparison(roots_data.x_2, test.r_data.x_2) == 1 || (isnan(roots_data.x_2) && isnan(test.r_data.x_2)))&&
        roots_data.n_roots == test.r_data.n_roots)
    {
        printf("\x1b[92mTEST %d SUCCESSED (x1 = %lg (%lg), x2 = %lg (%lg), NUMBER OF ROOTS = %d (%d))\x1b[0m\n",
                n_test+1, roots_data.x_1, test.r_data.x_1, roots_data.x_2, test.r_data.x_2, roots_data.n_roots, test.r_data.n_roots);
        return 1;
    }
    else
    {
        printf("\x1b[31mTEST %d FAILED (x1 = %lg (%lg), x2 = %lg (%lg), NUMBER OF ROOTS = %d (%d))\x1b[0m\n",
                n_test+1, roots_data.x_1, test.r_data.x_1, roots_data.x_2, test.r_data.x_2, roots_data.n_roots, test.r_data.n_roots);
            }
    return 0;
}

int DoubleComparisonWithZero(double number)
{
    if (fabs(number) < DELTA)
    {
        return 1;
    }
    return 0;
}

int DoubleComparison(double number_1, double number_2)
{
    if (DoubleComparisonWithZero(number_1 - number_2))
    {
        return 1;
    }

    return 0;
}

void MinusZero(double * number)
{
    assert(number);

    if (DoubleComparisonWithZero(*number))
    {
        * number = 0;
    }
}

void RootsComparison(double * x_1, double * x_2)
{
    assert(x_1);
    assert(x_2);
    assert(x_1 != x_2);

    double roots_swaper = 0;

    if ((*x_1 - *x_2) < -DELTA)
    {
        roots_swaper = * x_1;
        * x_1 = * x_2;
        * x_2 = roots_swaper;
    }
}

void BufferClear()
{
    int ch = 0;
    while ((ch = getchar()) != '\n' && ch != EOF && ch != EOF_NUMBER) {}
}
